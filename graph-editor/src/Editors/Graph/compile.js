import { getFilePath } from "../../useFile";
const AdmZip = window.require("adm-zip");
const fs = window.require("fs");
const path = window.require("path");

let warn;
warn =  "//================================================================================//\n";
warn += "//                            DO NOT EDIT THIS FILE                               //\n";
warn += "//   It is automatically generated from an obn file, changes will not be saved.   //\n";
warn += "//================================================================================//\n\n";

function compileApp(graph) {
    let zip = new ZipBetter();
    let front = zip.addFolder("front");
    let back = zip.addFolder("back");
    let aDef = compileGraph(null, { parentFront: front, parentBack: back }, graph);

    return [zip.zip, aDef.meta.name];
}

function compileGraph(graphPath, { parentFront, parentBack }, graph) {
    graph = graph || JSON.parse(fs.readFileSync(graphPath, "utf8"));
    graph.path = graph.path || path.dirname(graphPath);
    let name = graph.meta.name;

    let front = parentFront.addFolder(name);
    let back = parentBack.addFolder(name);

    // Add Node Modules
    /*
    console.log(graph);
    let packPath = path.join(graph.path, "front", "node_modules");
    if (fs.existsSync(packPath))
        front.importFolder(packPath, "node_modules");

    packPath = path.join(graph.path, "back", "node_modules");
    if (fs.existsSync(packPath))
        back.importFolder(packPath, "node_modules");*/

    // Get metadata
    let meta = {
        name,
        author: graph.meta.author,
        description: graph.meta.description
    };

    // Add Nodes
    let out = Object.values(graph.nodes).find(v => v.type === "out");
    let outKey = graph.ports[graph.links[out.inputs[0]]].node;
    
    let gDef = {
        nodes: {},
        recv: [],
        output: graph.nodes[outKey].name,
        inSides: {},
        outSide: "",
        meta
    };

    gDef.outSide = compileNode(graph, outKey, "?", gDef, { front, back });

    if (hasSide("?", gDef.outSide))
        throw new Error("Outputted node must be a Front, Back, or Graph node.")

    addExtras(gDef, "F", front);
    addExtras(gDef, "B", back);

    return gDef;
}

function hasSide(char, side) {
    return side.indexOf(char) !== -1;
}

function compileNode(graph, key, prevSide, gDef, folders) {
    let node = graph.nodes[key];
    let name = node.name;
    let side = prevSide;

    if (node.type === "out")
        throw new Error("Output nodes cannot be compiled");

    else if (node.type === "in") {
        gDef.nodes[name] = { "type": "in", side, "label": node.name };
        gDef.inSides[name] = side;
    }

    else if (node.type === "front" || node.type === "back") {
        // Get path to the source code
        let srcPath = getFilePath(node.name, node.type, graph.path);

        // Copy into front/ or back/
        folders[node.type].importFile(srcPath, path.basename(srcPath), warn);

        side = {front: "F", back: "B"}[node.type];

        if (hasSide("F", side) && hasSide(prevSide, "B"))
            throw new Error("You have a Front node outputting to a Back node, this is not allowed yet.");

        // Graph.recv stores names of nodes that can receive requests from the frontend
        if (hasSide("B", side) && hasSide(prevSide, "F"))
            gDef.recv.push(name);
            
        let inputs = resolveInputs(graph, node.inputs);

        // Log node in the graph definition
        gDef.nodes[name] = { type: "code", side, inputs };

        // Compile all inputting nodes
        propagate(graph, node.inputs, side, gDef, folders);
    }
    else if (node.type === "data") {
        // Get contents of the data file
        let dataPath = getFilePath(node.name, node.type, graph.path);
        let value = fs.readFileSync(dataPath).toString();

        gDef.nodes[name] = { type: "data", side, value };
    }
    else if (node.type === "edit") {
        gDef.nodes[name] = { type: "edit", side };
    }
    else if (node.type === "graph") {
        // Load the graph's data and compile it
        let subDef = compileGraph(node.path, { parentFront: folders.front, parentBack: folders.back });
        let allSides = [...Object.values(subDef.inSides), subDef.outSide];
        side = hasSide("F", allSides) ? "F" : "";
        side += hasSide("B", allSides) ? "B" : "";
        
        let inputs = resolveInputs(graph, node.inputs);
        gDef.nodes[name] = { type: "graph", side, inputs, graphName: subDef.meta.name, parameters: node.parameters };

        propagate(graph, node.inputs, subDef.inSides, gDef, folders);
    }

    return side;
}

function propagate(graph, inputs, side, gDef, folders) {
    // Compile all inputting nodes
    for (let input of inputs) {
        let s = side;

        if (typeof(side) === "object")
            s = side[graph.ports[input].label]  // side is a mapping of input labels to sides

        compileNode(graph, graph.ports[graph.links[input]].node, s, gDef, folders);
    }
}

function addExtras(gDef, side, folder) {
    folder.addFile("_index.js", compileIndex(gDef, side));
    folder.addFile("_graph.json", compileGraphInfo(gDef, side));
}

function compileIndex(gDef, side) {
    let content = "";

    for (let [name, nodeData] of Object.entries(gDef.nodes)) {
        if (!hasSide(side, nodeData.side))
            continue;

        if (nodeData.type === "data")
            content += `\t\t"${name}": ${JSON.stringify(nodeData.value)},\n`;
        if (nodeData.type === "code")
            content += `\t\t"${name}": require('./${name}'),\n`;
        if (nodeData.type === "graph")
            content += `\t\t"${name}": require('./${name}/_index'),\n`;
    }
    content += `\t},\n`;
    content += `\toutput: "${gDef.output}",\n`;
    content += `\tgraph: require('./_graph.json'),\n`;
    
    return warn + "module.exports = {\n\tnodes: {\n" + content + "};\n";
}

function compileGraphInfo(gDef, side) {
    let info = { nodes: {}, output: gDef.output, recv: gDef.recv, meta: gDef.meta };

    for (let [name, nodeData] of Object.entries(gDef.nodes)) {
        if (!hasSide(nodeData.side, side))
            continue;
        info.nodes[name] = nodeData;
    }
    
    return JSON.stringify(info, null, 2);
}

function resolveInput(graph, port) {
    let { links, ports, nodes } = graph;
    let sourceName = null;

    if (port in links) {
        let sourcePortKey = links[port];
        let sourceNodeKey = ports[sourcePortKey].node;
        let sourceNode = nodes[sourceNodeKey];
        sourceName = sourceNode.name;
    }

    return sourceName;
}

function resolveInputs(graph, inputs) {
    let result = {};

    for (let key of inputs) {
        let {label} = graph.ports[key];
        let sourceName = resolveInput(graph, key);
        result[label] = sourceName;
    }

    return result;
}

class ZipBetter {
    constructor(scope, zip) {
        this.scope = scope || "";
        this.zip = zip || new AdmZip();
        this.size = 0;
    }

    nameToPath(name, isDir) {
        let p = this.scope + name;

        if (isDir && !p.endsWith("/"))
            p += "/";
        if (!isDir && p.endsWith("/"))
            p = p.substring(0, p.length - 1);
        return p;
    }

    addFile(name, content) {
        this.zip.addFile(this.nameToPath(name, false), content);
        this.size++;
    }

    addFolder(name) {
        let path = this.nameToPath(name, true);
        this.zip.addFile(path, "");
        this.size++;
        return new ZipBetter(path, this.zip);
    }

    importFolder(localPath, zipName) {
        let zipPath = this.nameToPath(zipName, true);
        this.size++;
        this.zip.addLocalFolder(localPath, zipPath);
    }

    importFile(localPath, zipName, pre) {
        //let zipPath = this.nameToPath(zipName, false);
        this.size++;
        this.addFile(zipName, pre + fs.readFileSync(localPath).toString());
        //this.zip.addLocalFile(localPath, this.scope);
    }

    isEmpty() {
        return this.size > 0;
    }
}

export default compileApp;
